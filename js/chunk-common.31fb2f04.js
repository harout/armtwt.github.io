(globalThis["webpackChunktwitter_stats_display"]=globalThis["webpackChunktwitter_stats_display"]||[]).push([[64],{289:(e,t,r)=>{"use strict";r.d(t,{Z:()=>i});var s=r(8761),n=r.n(s),u=(r(9665),r(5231),r(3075),r(548),r(7664),r(3703),r(4170),r(2109)),o=r(425);class i{constructor(){}static get unngroupedGroupingName(){return"[Ungrouped]"}async loadDatabase(e){const t=r(1584),s=t({locateFile:e=>`${e}`}),n=fetch("twitter-stats.db.encrypted").then((e=>e.text())),[u,i]=await Promise.all([s,n]),a=o.AES.decrypt(i.toString(),e);try{this.db=new u.Database(this._cryptJsWordArrayToUint8Array(a))}catch{return Promise.reject()}return this.db.run("ALTER TABLE users RENAME TO original_users"),this.db.run("ALTER TABLE userMetrics RENAME TO original_userMetrics"),this.db.run("ALTER TABLE userProfileChanges RENAME TO original_userProfileChanges"),this.db.run("ALTER TABLE tweets RENAME TO original_tweets"),this.db.run("ALTER TABLE userTags RENAME TO original_userTags"),Promise.resolve(!0)}getDataForPeriod(e,t,r){this.db.run("DROP TABLE IF EXISTS users"),this.db.run("DROP TABLE IF EXISTS userMetrics"),this.db.run("DROP TABLE IF EXISTS userProfileChanges"),this.db.run("DROP TABLE IF EXISTS tweets"),this.db.run("DROP TABLE IF EXISTS userTags"),this.db.run("CREATE TABLE users AS SELECT * FROM original_users"),this.db.run("CREATE TABLE userMetrics AS SELECT * FROM original_userMetrics"),this.db.run("CREATE TABLE userProfileChanges AS SELECT * FROM original_userProfileChanges"),this.db.run("CREATE TABLE tweets AS SELECT * FROM original_tweets"),this.db.run("CREATE TABLE userTags AS SELECT * FROM original_userTags"),this._removedDataForExcludedTags(e);const s={};return s.overviewStatsForPeriod=this._getOverviewStatsForPeriod(t,r),s.engagementDataByTagForPeriod=this._getEngagementDataByTagForPeriod(t,r),s.engagementDataByUserAndTagForPeriod=this._getEngagementDataByUserAndTagForPeriod(t,r),s.dailyStatsByTag=this._getDailyStatsByTag(t,r),s.wordCount=this._getWordStatsByTag(t,r),s.weightedWordCount=this._getWeightedWordStatsByTag(t,r),s.topTweets=this._getTopTweetsByTag(t,r),s}getUserMetricsForPeriod(e,t,r){const s="\n      SELECT\n        userMetrics.followersCount,\n        userMetrics.listedCount,\n        DATE(userMetrics.recordedAt, 'unixepoch') AS reportingDay\n      FROM\n        users\n      JOIN\n        userMetrics ON users.userId = userMetrics.userId\n      WHERE\n        username = $username AND\n        reportingDay >= DATE($start, 'unixepoch') AND\n        reportingDay <= DATE($end, 'unixepoch')\n      GROUP BY\n        reportingDay\n      ORDER BY\n        reportingDay",n=this._execQueryAndFetchResults(s,{$start:t,$end:r,$username:e}),u={followersCount:[],listedCount:[]};return n.forEach((e=>{u.followersCount.push([e.reportingDay,e.followersCount]),u.listedCount.push([e.reportingDay,e.listedCount])})),u}getUser(e){return this._execQueryAndFetchResults("SELECT * FROM users WHERE username LIKE $username",{$username:e})[0]}getUsers(){return this._execQueryAndFetchResults("SELECT * FROM users ORDER BY followersCount DESC")}getTagsForUser(e){return this._execQueryAndFetchResults("SELECT\n        tag\n      FROM\n        users\n      JOIN\n        userTags ON users.userId = userTags.userId\n      WHERE\n        users.username LIKE $username",{$username:e})}getUserProfileChanges(e){return this._execQueryAndFetchResults("SELECT\n        userProfileChanges.*,\n        ROW_NUMBER() OVER(ORDER BY recordedAt) AS rowNumber\n       FROM\n        userProfileChanges\n       JOIN\n        users ON users.userId = userProfileChanges.userId\n      WHERE\n        username LIKE $username",{$username:e})}getUserDataForPeriod(e,t,r){this.db.run("DROP TABLE IF EXISTS users"),this.db.run("DROP TABLE IF EXISTS userMetrics"),this.db.run("DROP TABLE IF EXISTS userProfileChanges"),this.db.run("DROP TABLE IF EXISTS tweets"),this.db.run("DROP TABLE IF EXISTS userTags"),this.db.run("CREATE TABLE users AS SELECT * FROM original_users"),this.db.run("CREATE TABLE userMetrics AS SELECT * FROM original_userMetrics"),this.db.run("CREATE TABLE userProfileChanges AS SELECT * FROM original_userProfileChanges"),this.db.run("CREATE TABLE tweets AS SELECT * FROM original_tweets"),this.db.run("CREATE TABLE userTags AS SELECT * FROM original_userTags");const s="\n    SELECT\n      users.userId,\n      COUNT(*) AS tweetsSum,\n      SUM(views) AS viewsSum,\n      SUM(views) / CAST(COUNT(*) AS REAL) AS viewsPerTweet,\n      SUM(likesCount) AS likesSum,\n      SUM(likesCount) / CAST(COUNT(*) AS REAL) AS likesPerTweet,\n      SUM(quoteCount) AS quoteSum,\n      SUM(quoteCount) / CAST(COUNT(*) AS REAL) AS quotesPerTweet,\n      SUM(retweetCount) AS retweetSum,\n      SUM(retweetCount) / CAST(COUNT(*) AS REAL) AS retweetsPerTweet,\n      SUM(replyCount) AS replySum,\n      SUM(replyCount) / CAST(COUNT(*) AS REAL) AS repliesPerTweet,\n      SUM(hasVideo) AS videoSum,\n      100 * SUM(hasVideo) / CAST(COUNT(*) AS REAL) AS percentWithVideo,\n      SUM(hasPhoto) AS photoSum,\n      100 * SUM(hasPhoto) / CAST(COUNT(*) AS REAL) AS percentWithPhoto,\n      MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n      (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n      (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n      DATE(tweets.createdAt, 'unixepoch') AS tweetReportingDay\n    FROM\n      tweets\n    LEFT JOIN\n      users ON tweets.userId = users.userId\n    WHERE\n      tweets.createdAt >= $start AND\n      tweets.createdAt <= $end AND\n      isRetweet = 0 AND\n      users.username LIKE $username\n    GROUP BY\n      tweetReportingDay\n    ORDER BY\n      tweetReportingDay",n=this._execQueryAndFetchResults(s,{$start:t,$end:r,$username:e}),u={tweetsSum:[],viewsSum:[],viewsPerTweet:[],likesSum:[],likesPerTweet:[],quoteSum:[],quotesPerTweet:[],retweetSum:[],retweetsPerTweet:[],replySum:[],repliesPerTweet:[],videoSum:[],percentWithVideo:[],photoSum:[],percentWithPhoto:[],minKnownAudience:[],interactionsSum:[],interactionsPerTweet:[]};n.forEach((e=>{null!=e.tweetReportingDay&&(u.viewsSum.push([e.tweetReportingDay,e.viewsSum]),u.viewsSum.push([e.tweetReportingDay,e.viewsPerTweet]),u.quoteSum.push([e.tweetReportingDay,e.quoteSum]),u.quotesPerTweet.push([e.tweetReportingDay,e.quotesPerTweet]),u.repliesPerTweet.push([e.tweetReportingDay,e.repliesPerTweet]),u.replySum.push([e.tweetReportingDay,e.replySum]),u.retweetSum.push([e.tweetReportingDay,e.retweetSum]),u.retweetsPerTweet.push([e.tweetReportingDay,e.retweetsPerTweet]),u.tweetsSum.push([e.tweetReportingDay,e.tweetsSum]),u.likesSum.push([e.tweetReportingDay,e.likesSum]),u.likesPerTweet.push([e.tweetReportingDay,e.likesPerTweet]),u.interactionsSum.push([e.tweetReportingDay,e.interactionsSum]),u.interactionsPerTweet.push([e.tweetReportingDay,e.interactionsPerTweet]),u.photoSum.push([e.tweetReportingDay,e.photoSum]),u.percentWithPhoto.push([e.tweetReportingDay,e.percentWithPhoto]),u.videoSum.push([e.tweetReportingDay,e.videoSum]),u.percentWithVideo.push([e.tweetReportingDay,e.percentWithVideo]),u.percentWithVideo.push([e.tweetReportingDay,e.percentWithVideo]))}));const o="\n      SELECT\n        tweets.*\n      FROM\n        users\n      JOIN\n        tweets ON users.userId = tweets.userId\n      WHERE\n        users.username LIKE $username AND\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0\n      ORDER BY\n        views + likesCount + quoteCount + retweetCount + replyCount DESC\n      LIMIT 10",i=this._execQueryAndFetchResults(o,{$start:t,$end:r,$username:e});return u.topTweets=i,u}_removedDataForExcludedTags(e){e.forEach((e=>{const t="DELETE FROM userTags WHERE tag = $tag";this.db.run(t,{$tag:e})}));var t="DELETE FROM\n                    userMetrics\n                  WHERE\n                    userId\n                  NOT IN\n                    (SELECT\n                      userId\n                    FROM\n                      userTags)";this.db.run(t);t="DELETE FROM\n                  userProfileChanges\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t);t="DELETE FROM\n                  tweets\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t);t="DELETE FROM\n                  users\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t)}_getWordStatsByTag(e,t){const r="SELECT\n                    tag,\n                    body\n                  FROM\n                    tweets\n                  JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON tweets.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",s=this._execQueryAndFetchResults(r,{$start:e,$end:t}),n={};s.forEach((e=>{const t=e.tag;n.hasOwnProperty(t)||(n[t]={});const r=(0,u.removeStopwords)(e.body.split(" "),[...u.eng,...u.hye,...i.customStopwords]);r.forEach((e=>{e=e.replace(",",""),e=e.replace(",",""),e=e.replace('"',""),e=e.replace(".",""),e=e.replace("“",""),e=e.replace("”",""),e=e.replace("?",""),e=e.toLocaleLowerCase(),n[t].hasOwnProperty(e)||(n[t][e]=0),n[t][e]+=1}))}));const o={};for(const[u,i]of Object.entries(n)){const e=[];for(const[t,r]of Object.entries(i))e.push([t,r]);e.sort((function(e,t){return t[1]-e[1]})),o[u]=e.slice(0,20)}return o}_getWeightedWordStatsByTag(e,t){const r="SELECT\n                    tag,\n                    body,\n                    (views + likesCount + quoteCount + retweetCount + replyCount) AS weight\n                  FROM\n                    tweets\n                  JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON tweets.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",s=this._execQueryAndFetchResults(r,{$start:e,$end:t}),n={};s.forEach((e=>{const t=e.tag;n.hasOwnProperty(t)||(n[t]={});const r=(0,u.removeStopwords)(e.body.split(" "),[...u.eng,...u.hye,...i.customStopwords]);r.forEach((r=>{r=r.replace(",",""),r=r.replace(",",""),r=r.replace('"',""),r=r.replace(".",""),r=r.replace("“",""),r=r.replace("”",""),r=r.replace("?",""),r=r.toLocaleLowerCase(),n[t].hasOwnProperty(r)||(n[t][r]=0),n[t][r]+=Number(e.weight)}))}));const o={};for(const[u,i]of Object.entries(n)){const e=[];for(const[t,r]of Object.entries(i))e.push([t,r]);e.sort((function(e,t){return t[1]-e[1]})),o[u]=e.slice(0,20)}return o}getUsersWeightForTagByTag(e,t){const r={},s=this.getTags();s.forEach((e=>{r[e]=[]}));const n="SELECT\n                      SUM(views + likesCount + quoteCount + retweetCount) AS weight,\n                      users.username,\n                      users.name,\n                      userTags.tag\n                    FROM\n                      tweets\n                    JOIN\n                      users ON tweets.userId = users.userId\n                    JOIN\n                      userTags ON users.userId = userTags.userId\n                    WHERE\n                        tweets.createdAt >= $start AND\n                        tweets.createdAt <= $end AND\n                        tweets.isRetweet = 0\n                    GROUP BY username, tag\n                    ORDER BY\n                      weight DESC",u=this._execQueryAndFetchResults(n,{$start:e,$end:t});return u.forEach((e=>{const t=e.tag;r[t].push({x:e.username,y:e.weight})})),r}getWordUsageByTagAndTime(e,t,r){const s="SELECT\n                        COUNT(*) AS numMatching,\n                        tag,\n                        strftime(\"%m/%d/%Y\", createdAt, 'unixepoch') AS reportingDay\n                      FROM\n                        tweets\n                      LEFT JOIN\n                          userTags ON tweets.userId = userTags.userId\n                      WHERE\n                        tweets.createdAt >= $start AND\n                        tweets.createdAt <= $end AND\n                        tweets.isRetweet = 0 AND\n                        body LIKE $word\n                      GROUP BY reportingDay, tag",n=this._execQueryAndFetchResults(s,{$start:t,$end:r,$word:"%"+e+"%"}),u="SELECT\n                  COUNT(*) AS tweetsSum,\n                  tag,\n                  strftime(\"%m/%d/%Y\", createdAt, 'unixepoch') AS reportingDay\n                FROM\n                  tweets\n                LEFT JOIN\n                    userTags ON tweets.userId = userTags.userId\n                WHERE\n                  tweets.createdAt >= $start AND\n                  tweets.createdAt <= $end AND\n                  tweets.isRetweet = 0\n                GROUP BY reportingDay, tag",o=this._execQueryAndFetchResults(u,{$start:t,$end:r}),i=[];return n.forEach((e=>{const t=o.find((t=>t.tag==e.tag&&t.reportingDay==e.reportingDay)),r=100*Number(e.numMatching)/Number(t.tweetsSum),s=i.find((t=>t.name===e.tag));void 0!==s?s.data.push([e.reportingDay,r]):i.push({name:e.tag,data:[[e.reportingDay,r]]})})),i}_getTopTweetsByTag(e,t){const r="SELECT\n                    *\n                   FROM\n                      (SELECT\n                        tag,\n                        tweetId,\n                        row_number() OVER\n                          (PARTITION BY\n                            tag\n                          ORDER BY\n                            views + likesCount + quoteCount + retweetCount + replyCount DESC) AS tagRank\n                        FROM\n                          tweets\n                        JOIN\n                          users ON tweets.userId = users.userId,\n                          userTags ON users.userId = userTags.userId\n                        WHERE\n                          tweets.createdAt >= $start AND\n                          tweets.createdAt <= $end AND\n                          isRetweet = 0\n                        ORDER BY\n                          tag,\n                          tagRank)\n                    WHERE\n                      tagRank <= 5",s=this._execQueryAndFetchResults(r,{$start:e,$end:t}),n={};return s.forEach((e=>{n.hasOwnProperty(e.tag)||(n[e.tag]=[]),n[e.tag].push(e)})),n}_getDailyStatsByTag(e,t){const r="SELECT\n                    tag,\n                    COUNT(*) AS tweetsSum,\n                    SUM(views) AS viewsSum,\n                    SUM(views) / CAST(COUNT(*)  AS REAL) AS viewsPerTweet,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    SUM(hasVideo) AS videoSum,\n                    100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n                    SUM(hasPhoto) AS photoSum,\n                    100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n                    MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    DATE(tweets.createdAt, 'unixepoch') AS reportingDay\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON users.userId = tweets.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    tag,\n                    reportingDay\n                  ORDER BY\n                    tag,\n                    reportingDay",s=this._execQueryAndFetchResults(r,{$start:e,$end:t}),n={tweetsSum:{},viewsSum:{},viewsPerTweet:{},likesSum:{},likesPerTweet:{},quoteSum:{},quotesPerTweet:{},retweetSum:{},retweetsPerTweet:{},replySum:{},repliesPerTweet:{},videoSum:{},percentWithVideo:{},photoSum:{},percentWithPhoto:{},minKnownAudience:{},interactionsSum:{},interactionsPerTweet:{}};return s.forEach((e=>{n.likesSum.hasOwnProperty(e.tag)||(n.viewsSum[e.tag]=[],n.viewsPerTweet[e.tag]=[],n.tweetsSum[e.tag]=[],n.likesSum[e.tag]=[],n.likesPerTweet[e.tag]=[],n.interactionsSum[e.tag]=[],n.interactionsPerTweet[e.tag]=[],n.videoSum[e.tag]=[],n.percentWithVideo[e.tag]=[],n.photoSum[e.tag]=[],n.percentWithPhoto[e.tag]=[]),null!=e.reportingDay&&(n.viewsSum[e.tag].push([e.reportingDay,e.viewsSum]),n.viewsPerTweet[e.tag].push([e.reportingDay,e.viewsPerTweet]),n.tweetsSum[e.tag].push([e.reportingDay,e.tweetsSum]),n.likesSum[e.tag].push([e.reportingDay,e.likesSum]),n.likesPerTweet[e.tag].push([e.reportingDay,e.likesPerTweet]),n.interactionsSum[e.tag].push([e.reportingDay,e.interactionsSum]),n.interactionsPerTweet[e.tag].push([e.reportingDay,e.interactionsPerTweet]),n.photoSum[e.tag].push([e.reportingDay,e.photoSum]),n.percentWithPhoto[e.tag].push([e.reportingDay,e.percentWithPhoto]),n.videoSum[e.tag].push([e.reportingDay,e.videoSum]),n.percentWithVideo[e.tag].push([e.reportingDay,e.percentWithVideo]))})),n}_getOverviewStatsForPeriod(e,t){const r="SELECT\n                    tweetsSum,\n                    SUM(views) AS viewsSum,\n                    SUM(views) / CAST(COUNT(*)  AS REAL) AS viewsPerTweet,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    SUM(hasVideo) AS videoSum,\n                    100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n                    SUM(hasPhoto) AS photoSum,\n                    100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    users.userId,\n                    username,\n                    profileImage,\n                    name\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON users.userId = tweets.userId\n                  LEFT JOIN\n                    (SELECT\n                      userId,\n                      COUNT(*) AS tweetsSum\n                     FROM\n                      tweets\n                     WHERE\n                      tweets.createdAt >= $start AND\n                      tweets.createdAt <= $end AND\n                      isRetweet = 0\n                     GROUP BY userId) AS tweetCounts ON users.userId = tweetCounts.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    users.userId";return this._execQueryAndFetchResults(r,{$start:e,$end:t})}_getEngagementDataByUserAndTagForPeriod(e,t){const r="SELECT\n                    COUNT(*) AS tweetsSum,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount))  / SUM(views) AS interactionsPerView,\n                    users.userId,\n                    profileImage,\n                    username,\n                    tag\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    users.userId,\n                    userTags.tag";return this._execQueryAndFetchResults(r,{$start:e,$end:t})}_getEngagementDataByTagForPeriod(e,t){const r="SELECT\n                    userTags.tag,\n                    COUNT(*) AS tweetsSum,\n                    SUM(views) AS viewsSum,\n                    SUM(views) / CAST(COUNT(*)  AS REAL) AS viewsPerTweet,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount))  / SUM(views) AS interactionsPerView,\n                    users.userId\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    userTags.tag";return this._execQueryAndFetchResults(r,{$start:e,$end:t})}getTags(){const e="SELECT DISTINCT(tag) AS tag FROM original_userTags",t=this._execQueryAndFetchResults(e,{}),r=[];return t.forEach((e=>{r.push(e.tag)})),r}_execQueryAndFetchResults(e,t){var r=this.db.prepare(e);r.bind(t);const s=[];while(r.step())s.push(r.getAsObject(null,{useBigInt:!0}));return s}_resultsToDictionaries(e,t){const r=[];return t.forEach((t=>{const s={};e.forEach(((e,r)=>s[e]=t[r])),r.push(s)})),r}_cryptJsWordArrayToUint8Array(e){const t=e.sigBytes,r=e.words,s=new Uint8Array(t);var n=0,u=0;while(1){if(n==t)break;var o=r[u++];if(s[n++]=(4278190080&o)>>>24,n==t)break;if(s[n++]=(16711680&o)>>>16,n==t)break;if(s[n++]=(65280&o)>>>8,n==t)break;s[n++]=255&o}return s}}n()(i,"customStopwords",["&amp;","❗️","↵","","🔴","will","not","no","so","-","—","its","i'm"])},1168:(e,t,r)=>{"use strict";r.d(t,{Z:()=>E});var s=r(9835);function n(e,t,r,n,u,o){const i=(0,s.up)("q-date"),a=(0,s.up)("q-popup-proxy"),S=(0,s.up)("q-btn");return(0,s.wg)(),(0,s.j4)(S,{icon:"event",color:"primary",label:"Select Report Period",push:""},{default:(0,s.w5)((()=>[(0,s.Wm)(a,{"transition-show":"scale","transition-hide":"scale"},{default:(0,s.w5)((()=>[(0,s.Wm)(i,{modelValue:n.dateRange,"onUpdate:modelValue":t[0]||(t[0]=e=>n.dateRange=e),minimal:"",range:"",square:"",onRangeEnd:n.reportRequested},null,8,["modelValue","onRangeEnd"])])),_:1})])),_:1})}var u=r(499);const o={props:{from:{required:!0,type:String},to:{required:!0,type:String}},emits:["reportRequested"],setup(e,{emit:t}){const r=(0,u.iH)({from:e.from,to:e.to}),s=e=>{t("reportRequested",r.value)};return{reportRequested:s,dateRange:r}}};var i=r(1639),a=r(4455),S=r(2765),A=r(7088),T=r(9984),w=r.n(T);const d=(0,i.Z)(o,[["render",n]]),E=d;w()(o,"components",{QBtn:a.Z,QPopupProxy:S.Z,QDate:A.Z})},2480:()=>{},7607:()=>{},803:()=>{},9547:()=>{}}]);