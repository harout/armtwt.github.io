(globalThis["webpackChunktwitter_stats_display"]=globalThis["webpackChunktwitter_stats_display"]||[]).push([[64],{3622:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});var n=s(9302),r=s(3703),u=s(499);function o(e,t){const s=(0,u.iH)(""),o=(0,u.iH)(""),a=(0,u.iH)(0),i=(0,u.iH)(0),S=r.Z.getItem("password");var d=!1;const A=t=>{d=!0,e(a.value,i.value)},w=t=>{s.value=t.fromString,o.value=t.endString,a.value=t.fromTimestamp,i.value=t.endTimestamp,d&&e(a.value,i.value)};if(null==S){const e=(0,n.Z)();e.dialog({title:"Prompt",message:"Password?",prompt:{model:"",type:"password"},cancel:!0,persistent:!0}).onOk((e=>{t.loadDatabase(e).then((t=>{t?(r.Z.set("password",e),A()):r.Z.remove("password")}))}))}else{const e=r.Z.getItem("password");t.loadDatabase(e).then((e=>{e?A():r.Z.remove("password")}))}return{twitterDataService:t,dateRangeFromString:s,dateRangeToString:o,fromTimestamp:a,endTimestamp:i,handleReportRequested:w,handleDatabaseLoaded:A}}},289:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});var n=s(8761),r=s.n(n),u=(s(5231),s(3075),s(548),s(2279),s(2157),s(6735),s(9665),s(7664),s(3703),s(4170),s(2109));s(425),s(872);class o{constructor(){}static get unngroupedGroupingName(){return"[Ungrouped]"}async loadDatabase(e){const t=s(1584),n=t({locateFile:e=>`${e}`}),r=fetch("twitter-stats.encrypted").then((e=>e.arrayBuffer())),[u,o]=await Promise.all([n,r]),a=await this.decryptData(o,e),i=new Uint8Array(a);try{this.db=new u.Database(i)}catch{return console.log("exception"),Promise.reject()}this.db.run("ALTER TABLE users RENAME TO original_users"),this.db.run("ALTER TABLE userMetrics RENAME TO original_userMetrics"),this.db.run("ALTER TABLE userProfileChanges RENAME TO original_userProfileChanges"),this.db.run("ALTER TABLE tweets RENAME TO original_tweets"),this.db.run("ALTER TABLE userTags RENAME TO original_userTags");const S="SELECT\n                    *\n                   FROM\n                    original_users\n                   WHERE\n                    userId NOT IN (SELECT userId FROM original_userTags)",d=this._execQueryAndFetchResults(S,{});return d.forEach((e=>{const t="INSERT INTO original_userTags (userId, tag) VALUES ($userId, 'Untagged')";this.db.run(t,{$userId:e.userId})})),Promise.resolve(!0)}getKeyMaterial(e){const t=new TextEncoder;return crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"])}async getKey(e){const t=await this.getKeyMaterial(e),s=new TextEncoder,n=(Uint8Array[250],await crypto.subtle.deriveKey({name:"PBKDF2",salt:s.encode(e),iterations:1e5,hash:"SHA-256"},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]));return n}async decryptData(e,t){const s=await this.getKey(t),n=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);new Uint8Array(e);return await crypto.subtle.decrypt({name:"AES-GCM",iv:n},s,e)}prepareDataForPeriod(e){this.db.run("DROP TABLE IF EXISTS users"),this.db.run("DROP TABLE IF EXISTS userMetrics"),this.db.run("DROP TABLE IF EXISTS userProfileChanges"),this.db.run("DROP TABLE IF EXISTS tweets"),this.db.run("DROP TABLE IF EXISTS userTags"),this.db.run("CREATE TABLE users AS SELECT * FROM original_users"),this.db.run("CREATE TABLE userMetrics AS SELECT * FROM original_userMetrics"),this.db.run("CREATE TABLE userProfileChanges AS SELECT * FROM original_userProfileChanges"),this.db.run("CREATE TABLE tweets AS SELECT * FROM original_tweets"),this.db.run("CREATE TABLE userTags AS SELECT * FROM original_userTags"),this._removedDataForExcludedTags(e)}getDataForPeriod(e,t,s){this.prepareDataForPeriod(e);const n={};return n.overviewStatsForPeriod=this.getUserStatsForPeriod(t,s),n.engagementDataByTagForPeriod=this.getEngagementDataByTagForPeriod(t,s),n.engagementDataByUserAndTagForPeriod=this._getEngagementDataByUserAndTagForPeriod(t,s),n.dailyStatsByTag=this._getDailyStatsByTag(t,s),n.wordCount=this._getWordStatsByTag(t,s),n.weightedWordCount=this.getWeightedWordStatsByTag(t,s),n.topTweets=this.getTopTweetsByTag(t,s),n}getUserMetricsForPeriod(e,t,s){const n="\n      SELECT\n        userMetrics.followersCount,\n        userMetrics.listedCount,\n        DATE(userMetrics.recordedAt, 'unixepoch') AS reportingDay\n      FROM\n        users\n      JOIN\n        userMetrics ON users.userId = userMetrics.userId\n      WHERE\n        username = $username AND\n        reportingDay >= DATE($start, 'unixepoch') AND\n        reportingDay <= DATE($end, 'unixepoch')\n      GROUP BY\n        reportingDay\n      ORDER BY\n        reportingDay",r=this._execQueryAndFetchResults(n,{$start:t,$end:s,$username:e}),u={followersCount:[],listedCount:[]};return r.forEach((e=>{u.followersCount.push([e.reportingDay,e.followersCount]),u.listedCount.push([e.reportingDay,e.listedCount])})),u}getUser(e){return this._execQueryAndFetchResults("SELECT * FROM users WHERE username LIKE $username",{$username:e})[0]}getUsers(){return this._execQueryAndFetchResults("SELECT * FROM users ORDER BY followersCount DESC")}getTagsForUsers(){const e="SELECT * FROM userTags",t=this._execQueryAndFetchResults(e,{}),s={};return t.forEach((e=>{s.hasOwnProperty(e.userId)||(s[e.userId]=[]),s[e.userId].push(e.tag)})),s}getTagsForUser(e){return this._execQueryAndFetchResults("SELECT\n        tag\n      FROM\n        users\n      JOIN\n        userTags ON users.userId = userTags.userId\n      WHERE\n        users.username LIKE $username",{$username:e})}getUserProfileChanges(e){return this._execQueryAndFetchResults("SELECT\n        userProfileChanges.*,\n        ROW_NUMBER() OVER(ORDER BY recordedAt) AS rowNumber\n       FROM\n        userProfileChanges\n       JOIN\n        users ON users.userId = userProfileChanges.userId\n      WHERE\n        username LIKE $username",{$username:e})}getUserDataForPeriod(e,t,s){this.db.run("DROP TABLE IF EXISTS users"),this.db.run("DROP TABLE IF EXISTS userMetrics"),this.db.run("DROP TABLE IF EXISTS userProfileChanges"),this.db.run("DROP TABLE IF EXISTS tweets"),this.db.run("DROP TABLE IF EXISTS userTags"),this.db.run("CREATE TABLE users AS SELECT * FROM original_users"),this.db.run("CREATE TABLE userMetrics AS SELECT * FROM original_userMetrics"),this.db.run("CREATE TABLE userProfileChanges AS SELECT * FROM original_userProfileChanges"),this.db.run("CREATE TABLE tweets AS SELECT * FROM original_tweets"),this.db.run("CREATE TABLE userTags AS SELECT * FROM original_userTags");const n="\n    SELECT\n      users.userId,\n      COUNT(*) AS tweetsSum,\n      SUM(views) AS viewsSum,\n      SUM(views) / CAST(COUNT(*) AS REAL) AS viewsPerTweet,\n      SUM(likesCount) AS likesSum,\n      SUM(likesCount) / CAST(COUNT(*) AS REAL) AS likesPerTweet,\n      SUM(quoteCount) AS quoteSum,\n      SUM(quoteCount) / CAST(COUNT(*) AS REAL) AS quotesPerTweet,\n      SUM(retweetCount) AS retweetSum,\n      SUM(retweetCount) / CAST(COUNT(*) AS REAL) AS retweetsPerTweet,\n      SUM(replyCount) AS replySum,\n      SUM(replyCount) / CAST(COUNT(*) AS REAL) AS repliesPerTweet,\n      SUM(hasVideo) AS videoSum,\n      100 * SUM(hasVideo) / CAST(COUNT(*) AS REAL) AS percentWithVideo,\n      SUM(hasPhoto) AS photoSum,\n      100 * SUM(hasPhoto) / CAST(COUNT(*) AS REAL) AS percentWithPhoto,\n      MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n      (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n      (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n      DATE(tweets.createdAt, 'unixepoch') AS tweetReportingDay\n    FROM\n      tweets\n    LEFT JOIN\n      users ON tweets.userId = users.userId\n    WHERE\n      tweets.createdAt >= $start AND\n      tweets.createdAt <= $end AND\n      isRetweet = 0 AND\n      users.username LIKE $username\n    GROUP BY\n      tweetReportingDay\n    ORDER BY\n      tweetReportingDay",r=this._execQueryAndFetchResults(n,{$start:t,$end:s,$username:e}),u={tweetsSum:[],viewsSum:[],viewsPerTweet:[],likesSum:[],likesPerTweet:[],quoteSum:[],quotesPerTweet:[],retweetSum:[],retweetsPerTweet:[],replySum:[],repliesPerTweet:[],videoSum:[],percentWithVideo:[],photoSum:[],percentWithPhoto:[],minKnownAudience:[],interactionsSum:[],interactionsPerTweet:[]};r.forEach((e=>{null!=e.tweetReportingDay&&(u.viewsSum.push([e.tweetReportingDay,e.viewsSum]),u.viewsPerTweet.push([e.tweetReportingDay,e.viewsPerTweet]),u.quoteSum.push([e.tweetReportingDay,e.quoteSum]),u.quotesPerTweet.push([e.tweetReportingDay,e.quotesPerTweet]),u.repliesPerTweet.push([e.tweetReportingDay,e.repliesPerTweet]),u.replySum.push([e.tweetReportingDay,e.replySum]),u.retweetSum.push([e.tweetReportingDay,e.retweetSum]),u.retweetsPerTweet.push([e.tweetReportingDay,e.retweetsPerTweet]),u.tweetsSum.push([e.tweetReportingDay,e.tweetsSum]),u.likesSum.push([e.tweetReportingDay,e.likesSum]),u.likesPerTweet.push([e.tweetReportingDay,e.likesPerTweet]),u.interactionsSum.push([e.tweetReportingDay,e.interactionsSum]),u.interactionsPerTweet.push([e.tweetReportingDay,e.interactionsPerTweet]),u.photoSum.push([e.tweetReportingDay,e.photoSum]),u.percentWithPhoto.push([e.tweetReportingDay,e.percentWithPhoto]),u.videoSum.push([e.tweetReportingDay,e.videoSum]),u.percentWithVideo.push([e.tweetReportingDay,e.percentWithVideo]),u.percentWithVideo.push([e.tweetReportingDay,e.percentWithVideo]))}));const o="\n      SELECT\n        tweets.*\n      FROM\n        users\n      JOIN\n        tweets ON users.userId = tweets.userId\n      WHERE\n        users.username LIKE $username AND\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0\n      ORDER BY\n        views + likesCount + quoteCount + retweetCount + replyCount DESC\n      LIMIT 10",a=this._execQueryAndFetchResults(o,{$start:t,$end:s,$username:e});return u.topTweets=a,u}_removedDataForExcludedTags(e){e.forEach((e=>{const t="DELETE FROM userTags WHERE tag = $tag";this.db.run(t,{$tag:e})}));var t="DELETE FROM\n                    userMetrics\n                  WHERE\n                    userId\n                  NOT IN\n                    (SELECT\n                      userId\n                    FROM\n                      userTags)";this.db.run(t);t="DELETE FROM\n                  userProfileChanges\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t);t="DELETE FROM\n                  tweets\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t);t="DELETE FROM\n                  users\n                WHERE\n                  userId\n                NOT IN\n                  (SELECT\n                    userId\n                  FROM\n                    userTags)";this.db.run(t)}getNumTweetsForPeriod(e,t){const s="SELECT\n                    COUNT(tweetId) AS numTweets\n                   FROM\n                    tweets\n                   WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",n=this._execQueryAndFetchResults(s,{$start:e,$end:t});return n[0]["numTweets"]}getNumViewsForPeriod(e,t){const s="SELECT\n                    SUM(views) AS viewsSum\n                   FROM\n                    tweets\n                   WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",n=this._execQueryAndFetchResults(s,{$start:e,$end:t});return n[0]["viewsSum"]}getNumUsers(){const e="SELECT\n                    COUNT(*) AS numUsers\n                   FROM\n                    users",t=this._execQueryAndFetchResults(e,{});return t[0]["numUsers"]}getUsersWithNoTags(){const e="SELECT\n                    *\n                   FROM\n                    users\n                   WHERE\n                    userId NOT IN (SELECT userId FROM userTags)";return this._execQueryAndFetchResults(e,{})}getTopWordsForPeriod(e,t,s){const n="SELECT\n                    stemmedBody,\n                    views\n                   FROM\n                    tweets\n                   WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),u={};r.forEach((e=>{if(null!=e.stemmedBody){const t=e.stemmedBody.split(",");t.forEach((t=>{u.hasOwnProperty(t)||(u[t]=0),u[t]+=Number(e.views)}))}}));const o=[];for(const[a,i]of Object.entries(u))o.push([a,i]);return o.sort((function(e,t){return t[1]-e[1]})),o.slice(0,s)}_getWordStatsByTag(e,t){const s="SELECT\n                    tag,\n                    body\n                  FROM\n                    tweets\n                  JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON tweets.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",n=this._execQueryAndFetchResults(s,{$start:e,$end:t}),r={};n.forEach((e=>{const t=e.tag;r.hasOwnProperty(t)||(r[t]={});const s=(0,u.removeStopwords)(e.body.split(" "),[...u.eng,...u.hye,...o.customStopwords]);s.forEach((e=>{e=e.replace(",",""),e=e.replace(",",""),e=e.replace('"',""),e=e.replace(".",""),e=e.replace("â€œ",""),e=e.replace("â€",""),e=e.replace("?",""),e=e.toLocaleLowerCase(),r[t].hasOwnProperty(e)||(r[t][e]=0),r[t][e]+=1}))}));const a={};for(const[u,o]of Object.entries(r)){const e=[];for(const[t,s]of Object.entries(o))e.push([t,s]);e.sort((function(e,t){return t[1]-e[1]})),a[u]=e.slice(0,20)}return a}getWeightedWordStatsByTag(e,t,s){const n="SELECT\n                    tag,\n                    stemmedBody,\n                    (views + likesCount + quoteCount + retweetCount + replyCount) AS weight\n                  FROM\n                    tweets\n                  JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON tweets.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),u={};r.forEach((e=>{const t=e.tag;u.hasOwnProperty(t)||(u[t]={});const s=e.stemmedBody.split(",");s.forEach((s=>{u[t].hasOwnProperty(s)||(u[t][s]=0),u[t][s]+=Number(e.weight)}))}));const o={};for(const[a,i]of Object.entries(u)){const e=[];for(const[t,s]of Object.entries(i))e.push([t,s]);e.sort((function(e,t){return t[1]-e[1]})),o[a]=e.slice(0,s)}return o}getUsersContributionByTag(e,t){const s={},n=this.getTags();n.forEach((e=>{s[e]=[]}));const r="SELECT\n                      SUM(relevantTweets.views) AS viewsSum,\n                      COALESCE(SUM(relevantTweets.likesCount) / CAST(COUNT(relevantTweets.tweetId) AS REAL), 0) AS likesPerView,\n                      SUM(relevantTweets.likesCount) AS likesSum,\n                      SUM(relevantTweets.quoteCount) AS quotesSum,\n                      SUM(relevantTweets.retweetCount) AS retweetSum,\n                      users.username,\n                      users.name,\n                      userTags.tag\n                    FROM\n                      users\n                    JOIN\n                      userTags ON users.userId = userTags.userId\n                    LEFT JOIN\n                      (SELECT\n                        tweetId,\n                        userId,\n                        views,\n                        likesCount,\n                        quoteCount,\n                        retweetCount\n                      FROM\n                        tweets\n                      WHERE\n                        createdAt >= $start AND\n                        createdAt <= $end AND\n                        isRetweet = 0) AS relevantTweets ON users.userId = relevantTweets.userId\n                    GROUP BY username, tag",u=this._execQueryAndFetchResults(r,{$start:e,$end:t});return u.forEach((e=>{const t=e.tag;s[t].push(e)})),s}getUsersWeightForTagByTag(e,t){const s={},n=this.getTags();n.forEach((e=>{s[e]=[]}));const r="SELECT\n                      SUM(views + likesCount + quoteCount + retweetCount) AS weight,\n                      users.username,\n                      users.name,\n                      userTags.tag\n                    FROM\n                      tweets\n                    JOIN\n                      users ON tweets.userId = users.userId\n                    JOIN\n                      userTags ON users.userId = userTags.userId\n                    WHERE\n                        tweets.createdAt >= $start AND\n                        tweets.createdAt <= $end AND\n                        tweets.isRetweet = 0\n                    GROUP BY username, tag\n                    ORDER BY\n                      weight DESC",u=this._execQueryAndFetchResults(r,{$start:e,$end:t});return u.forEach((e=>{const t=e.tag;s[t].push({x:e.username,y:e.weight})})),s}getWordUsageByTagAndTime(e,t,s){const n="SELECT\n                        COUNT(*) AS numMatching,\n                        tag,\n                        strftime(\"%m/%d/%Y\", createdAt, 'unixepoch') AS reportingDay\n                      FROM\n                        tweets\n                      LEFT JOIN\n                          userTags ON tweets.userId = userTags.userId\n                      WHERE\n                        tweets.createdAt >= $start AND\n                        tweets.createdAt <= $end AND\n                        tweets.isRetweet = 0 AND\n                        body LIKE $word\n                      GROUP BY reportingDay, tag",r=this._execQueryAndFetchResults(n,{$start:t,$end:s,$word:"%"+e+"%"}),u="SELECT\n                  COUNT(*) AS tweetsSum,\n                  tag,\n                  strftime(\"%m/%d/%Y\", createdAt, 'unixepoch') AS reportingDay\n                FROM\n                  tweets\n                LEFT JOIN\n                    userTags ON tweets.userId = userTags.userId\n                WHERE\n                  tweets.createdAt >= $start AND\n                  tweets.createdAt <= $end AND\n                  tweets.isRetweet = 0\n                GROUP BY reportingDay, tag",o=this._execQueryAndFetchResults(u,{$start:t,$end:s}),a=[];return r.forEach((e=>{const t=o.find((t=>t.tag==e.tag&&t.reportingDay==e.reportingDay)),s=100*Number(e.numMatching)/Number(t.tweetsSum),n=a.find((t=>t.name===e.tag));void 0!==n?n.data.push([e.reportingDay,s]):a.push({name:e.tag,data:[[e.reportingDay,s]]})})),a}getTopTweetsUsingWord(e,t,s,n){const r="SELECT\n                    *,\n                    (views + likesCount + quoteCount + retweetCount + replyCount) AS weight\n                  FROM\n                    tweets\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0 AND\n                    stemmedBody LIKE $word\n                  ORDER BY\n                    weight DESC\n                  LIMIT $limit",u=this._execQueryAndFetchResults(r,{$start:e,$end:t,$word:"%"+s+"%",$limit:n});return u}getTopTweetsByTag(e,t){const s="SELECT\n                    *\n                   FROM\n                      (SELECT\n                        tag,\n                        tweetId,\n                        row_number() OVER\n                          (PARTITION BY\n                            tag\n                          ORDER BY\n                            views + likesCount + quoteCount + retweetCount + replyCount DESC) AS tagRank\n                        FROM\n                          tweets\n                        JOIN\n                          users ON tweets.userId = users.userId,\n                          userTags ON users.userId = userTags.userId\n                        WHERE\n                          tweets.createdAt >= $start AND\n                          tweets.createdAt <= $end AND\n                          isRetweet = 0\n                        ORDER BY\n                          tag,\n                          tagRank)\n                    WHERE\n                      tagRank <= 5",n=this._execQueryAndFetchResults(s,{$start:e,$end:t}),r={};return n.forEach((e=>{r.hasOwnProperty(e.tag)||(r[e.tag]=[]),r[e.tag].push(e)})),r}_getDailyStatsByTag(e,t){const s="SELECT\n                    tag,\n                    COUNT(*) AS tweetsSum,\n                    SUM(views) AS viewsSum,\n                    SUM(views) / CAST(COUNT(*)  AS REAL) AS viewsPerTweet,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    SUM(hasVideo) AS videoSum,\n                    100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n                    SUM(hasPhoto) AS photoSum,\n                    100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n                    MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    DATE(tweets.createdAt, 'unixepoch') AS reportingDay\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON users.userId = tweets.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    tag,\n                    reportingDay\n                  ORDER BY\n                    tag,\n                    reportingDay",n=this._execQueryAndFetchResults(s,{$start:e,$end:t}),r={tweetsSum:{},viewsSum:{},viewsPerTweet:{},likesSum:{},likesPerTweet:{},quoteSum:{},quotesPerTweet:{},retweetSum:{},retweetsPerTweet:{},replySum:{},repliesPerTweet:{},videoSum:{},percentWithVideo:{},photoSum:{},percentWithPhoto:{},minKnownAudience:{},interactionsSum:{},interactionsPerTweet:{}};return n.forEach((e=>{r.likesSum.hasOwnProperty(e.tag)||(r.viewsSum[e.tag]=[],r.viewsPerTweet[e.tag]=[],r.tweetsSum[e.tag]=[],r.likesSum[e.tag]=[],r.likesPerTweet[e.tag]=[],r.interactionsSum[e.tag]=[],r.interactionsPerTweet[e.tag]=[],r.videoSum[e.tag]=[],r.percentWithVideo[e.tag]=[],r.photoSum[e.tag]=[],r.percentWithPhoto[e.tag]=[]),null!=e.reportingDay&&(r.viewsSum[e.tag].push([e.reportingDay,e.viewsSum]),r.viewsPerTweet[e.tag].push([e.reportingDay,e.viewsPerTweet]),r.tweetsSum[e.tag].push([e.reportingDay,e.tweetsSum]),r.likesSum[e.tag].push([e.reportingDay,e.likesSum]),r.likesPerTweet[e.tag].push([e.reportingDay,e.likesPerTweet]),r.interactionsSum[e.tag].push([e.reportingDay,e.interactionsSum]),r.interactionsPerTweet[e.tag].push([e.reportingDay,e.interactionsPerTweet]),r.photoSum[e.tag].push([e.reportingDay,e.photoSum]),r.percentWithPhoto[e.tag].push([e.reportingDay,e.percentWithPhoto]),r.videoSum[e.tag].push([e.reportingDay,e.videoSum]),r.percentWithVideo[e.tag].push([e.reportingDay,e.percentWithVideo]))})),r}getTagMediaUsageForPeriod(e,t){}getUserStatsForPeriod(e,t){const s="SELECT\n                    COUNT(tweetId) AS tweetsSum,\n                    COALESCE(SUM(views), 0) AS viewsSum,\n                    COALESCE(SUM(views) / CAST(COUNT(tweetId) AS REAL), 0) AS viewsPerTweet,\n                    COALESCE(SUM(likesCount), 0) AS likesSum,\n                    COALESCE(SUM(likesCount) / CAST(COUNT(tweetId) AS REAL), 0) AS likesPerTweet,\n                    COALESCE(SUM(quoteCount), 0) AS quoteSum,\n                    COALESCE(SUM(quoteCount) / CAST(COUNT(tweetId) AS REAL), 0) AS quotesPerTweet,\n                    COALESCE(SUM(retweetCount), 0) AS retweetSum,\n                    COALESCE(SUM(retweetCount) / CAST(COUNT(tweetId) AS REAL), 0) AS retweetsPerTweet,\n                    COALESCE(SUM(replyCount), 0) AS replySum,\n                    COALESCE(SUM(replyCount) / CAST(COUNT(tweetId) AS REAL), 0) AS repliesPerTweet,\n                    COALESCE(SUM(hasVideo), 0) AS videoSum,\n                    COALESCE(100 * SUM(hasVideo) / CAST(COUNT(tweetId) AS REAL), 0) AS percentWithVideo,\n                    COALESCE(SUM(hasPhoto), 0) AS photoSum,\n                    COALESCE(100 * SUM(hasPhoto) / CAST(COUNT(tweetId) AS REAL), 0) AS percentWithPhoto,\n                    COALESCE((SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)), 0) AS interactionsSum,\n                    COALESCE((SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*) AS REAL), 0) AS interactionsPerTweet,\n                    COALESCE((SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / SUM(views), 0) AS interactionsPerView,\n                    users.userId,\n                    username,\n                    name\n                   FROM\n                    users\n                   LEFT JOIN\n                    (SELECT\n                      *\n                     FROM\n                      tweets\n                     WHERE\n                      createdAt >= $start AND\n                      createdAt <= $end AND\n                      isRetweet = 0) AS tweets ON users.userId = tweets.userId\n                    GROUP BY\n                      users.userId",n=this._execQueryAndFetchResults(s,{$start:e,$end:t}),r=this.getTagsForUsers();return n.forEach((e=>{e.tags=r[e.userId]})),n}_getEngagementDataByUserAndTagForPeriod(e,t){const s="SELECT\n                    COUNT(*) AS tweetsSum,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount))  / SUM(views) AS interactionsPerView,\n                    users.userId,\n                    username,\n                    tag\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    users.userId,\n                    userTags.tag";return this._execQueryAndFetchResults(s,{$start:e,$end:t})}getEngagementDataByTagForPeriod(e,t){const s="SELECT\n                    userTags.tag,\n                    COUNT(*) AS tweetsSum,\n                    SUM(views) AS viewsSum,\n                    SUM(views) / CAST(COUNT(*)  AS REAL) AS viewsPerTweet,\n                    SUM(likesCount) AS likesSum,\n                    SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n                    SUM(quoteCount) AS quoteSum,\n                    SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n                    SUM(retweetCount) AS retweetSum,\n                    SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n                    SUM(replyCount) AS replySum,\n                    SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n                    (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount))  / SUM(views) AS interactionsPerView,\n                    users.userId\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    userTags.tag";return this._execQueryAndFetchResults(s,{$start:e,$end:t})}getAllTweetsForPeriod(e,t){const s="SELECT\n                    tweets.body,\n                    tweets.views,\n                    tweets.likesCount,\n                    tweets.createdAt,\n                    users.username\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end";return this._execQueryAndFetchResults(s,{$start:e,$end:t})}getTimeOfDayDataByTagForPeriod(e,t){const s="SELECT\n                    userTags.tag,\n                    COUNT(*) AS tweetsSum,\n                    strftime('%H', datetime(tweets.createdAt, 'unixepoch', 'localtime')) AS timeOfDay\n                  FROM\n                    tweets\n                  LEFT JOIN\n                    users ON tweets.userId = users.userId,\n                    userTags ON users.userId = userTags.userId\n                  WHERE\n                    tweets.createdAt >= $start AND\n                    tweets.createdAt <= $end AND\n                    isRetweet = 0\n                  GROUP BY\n                    userTags.tag,\n                    timeOfDay",n=this._execQueryAndFetchResults(s,{$start:e,$end:t}),r={};return n.forEach((e=>{const t=e.tag;r.hasOwnProperty(t)||(r[t]=[]),r[t].push({timeOfDay:e.timeOfDay,tweetsSum:e.tweetsSum})})),r}getTags(){const e="SELECT DISTINCT(tag) AS tag FROM original_userTags",t=this._execQueryAndFetchResults(e,{}),s=[];return t.forEach((e=>{s.push(e.tag)})),s}_execQueryAndFetchResults(e,t){var s=this.db.prepare(e);s.bind(t);const n=[];while(s.step())n.push(s.getAsObject(null,{useBigInt:!0}));return n}_resultsToDictionaries(e,t){const s=[];return t.forEach((t=>{const n={};e.forEach(((e,s)=>n[e]=t[s])),s.push(n)})),s}_cryptJsWordArrayToUint8Array(e){const t=e.sigBytes,s=e.words,n=new Uint8Array(t);var r=0,u=0;while(1){if(r==t)break;var o=s[u++];if(n[r++]=(4278190080&o)>>>24,r==t)break;if(n[r++]=(16711680&o)>>>16,r==t)break;if(n[r++]=(65280&o)>>>8,r==t)break;n[r++]=255&o}return n}}r()(o,"customStopwords",["&amp;","â—ï¸","â†µ","","ðŸ”´","will","not","no","so","-","â€”","its","i'm"])},5958:(e,t,s)=>{"use strict";s.d(t,{Z:()=>O});var n=s(9835);const r={class:"row q-mt-md q-gutter-sm"};function u(e,t,s,u,o,a){const i=(0,n.up)("NewReportPeriodSelector"),S=(0,n.up)("q-btn");return(0,n.wg)(),(0,n.iD)("div",r,[(0,n.Wm)(i,{onReportRequested:s.handleReportRequested},null,8,["onReportRequested"]),(0,n.Wm)(S,{type:"a",href:"./#/",label:"Main Report",push:""}),(0,n.Wm)(S,{type:"a",href:"./#/tags",label:"Tags",push:""}),(0,n.Wm)(S,{type:"a",href:"./#/topics",label:"Topics",push:""}),(0,n.Wm)(S,{type:"a",href:"./#/individuals",label:"Individuals",push:""})])}function o(e,t,s,r,u,o){const a=(0,n.up)("q-date"),i=(0,n.up)("q-popup-proxy"),S=(0,n.up)("q-btn");return(0,n.wg)(),(0,n.j4)(S,{icon:"event",color:"primary",label:"Select Report Period",push:""},{default:(0,n.w5)((()=>[(0,n.Wm)(i,{"transition-show":"scale","transition-hide":"scale"},{default:(0,n.w5)((()=>[(0,n.Wm)(a,{modelValue:r.dateRange,"onUpdate:modelValue":t[0]||(t[0]=e=>r.dateRange=e),mask:"MMM DD, YYYY",minimal:"",range:"",square:"",onRangeEnd:r.reportRequested},null,8,["modelValue","onRangeEnd"])])),_:1})])),_:1})}var a=s(499),i=s(4170),S=s(3703);const{subtractFromDate:d,formatDate:A}=i["default"],w={props:{},emits:["reportRequested"],setup(e,{emit:t}){const s=(0,a.iH)({}),r="MMM DD, YYYY",u=()=>{const e=Date.now(),t=d(e,{days:7});var n=A(e,"MMM DD, YYYY"),u=A(t,"MMM DD, YYYY");const o=S.Z.getItem("dateSelection");null!=o&&o["saved"]>=e-864e5&&(u=A(o["from"],r),n=A(o["to"],r)),s.value={from:u,to:n}},o=(e,t)=>{const s=Date.now(),n={from:e,to:t,saved:s};S.Z.set("dateSelection",n)},w=e=>{const n=i["default"].extractDate(s.value.from,r),u=i["default"].extractDate(s.value.to,r),a=n.getTime()/1e3,S=i["default"].addToDate(u,{days:1}).getTime()/1e3;o(s.value.from,s.value.to),t("reportRequested",{fromString:s.value.from,endString:s.value.to,fromTimestamp:a,endTimestamp:S})};return(0,n.bv)((()=>{u(),w()})),{reportRequested:w,dateRange:s}}};var T=s(1639),c=s(4455),E=s(2765),l=s(7088),g=s(9984),C=s.n(g);const h=(0,T.Z)(w,[["render",o]]),p=h;C()(w,"components",{QBtn:c.Z,QPopupProxy:E.Z,QDate:l.Z});const R={components:{NewReportPeriodSelector:p},props:{handleReportRequested:{required:!0}}},m=(0,T.Z)(R,[["render",u]]),O=m;C()(R,"components",{QBtn:c.Z})},2922:(e,t,s)=>{"use strict";s.d(t,{Z:()=>h});var n=s(9835);const r={class:"col-xs-12 col-sm-12 col-md-12 col-lg-12"},u=(0,n._)("div",{class:"text-h6"},"Tags to Include in Report",-1),o=(0,n._)("br",null,null,-1);function a(e,t,s,a,i,S){const d=(0,n.up)("q-card-section"),A=(0,n.up)("q-separator"),w=(0,n.up)("q-checkbox"),T=(0,n.up)("q-btn"),c=(0,n.up)("q-card");return(0,n.wg)(),(0,n.iD)("div",r,[(0,n.Wm)(c,null,{default:(0,n.w5)((()=>[(0,n.Wm)(d,null,{default:(0,n.w5)((()=>[u])),_:1}),(0,n.Wm)(A),((0,n.wg)(!0),(0,n.iD)(n.HY,null,(0,n.Ko)(s.tags,(e=>((0,n.wg)(),(0,n.j4)(w,{key:e,modelValue:a.selectedTags,"onUpdate:modelValue":[t[0]||(t[0]=e=>a.selectedTags=e),a.selectedTagsChanged],val:e,label:e,"toggle-indeterminate":!1},null,8,["modelValue","val","label","onUpdate:modelValue"])))),128)),o,(0,n.Wm)(T,{class:"q-ma-md",onClick:a.uncheckAllTags,label:"Unckeck All"},null,8,["onClick"])])),_:1})])}var i=s(499);const S={props:{tags:{required:!0}},emits:["selectedTagsChanged"],setup(e,{emit:t}){const s=(0,i.iH)([]);var r=null;const u=()=>{null!=r&&clearTimeout(r),r=setTimeout((()=>t("selectedTagsChanged",{selectedTags:s.value})),750)},o=()=>{const e=s.value.length;s.value=[],0!=e&&u()};return(0,n.YP)((()=>e.tags),((e,t)=>{JSON.stringify(e)!==JSON.stringify(t)&&(s.value=e,u())})),{selectedTags:s,selectedTagsChanged:u,uncheckAllTags:o}}};var d=s(1639),A=s(4458),w=s(3190),T=s(926),c=s(1221),E=s(4455),l=s(9984),g=s.n(l);const C=(0,d.Z)(S,[["render",a]]),h=C;g()(S,"components",{QCard:A.Z,QCardSection:w.Z,QSeparator:T.Z,QCheckbox:c.Z,QBtn:E.Z})},2480:()=>{},7607:()=>{},803:()=>{},9547:()=>{},872:()=>{}}]);