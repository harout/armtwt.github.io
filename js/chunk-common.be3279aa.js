(self["webpackChunktwitter_stats_display"]=self["webpackChunktwitter_stats_display"]||[]).push([[64],{289:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(5148),s=n.n(r),o=(n(702),n(8170),n(5231),n(9359),n(6408),n(7664),n(3703),n(4170),n(2109)),u=n(425);class i{constructor(){}static get unngroupedGroupingName(){return"[Ungrouped]"}async loadDatabase(e){const t=n(1584),r=t({locateFile:e=>`${e}`}),s=fetch("twitter-stats.db.encrypted").then((e=>e.text())),[o,i]=await Promise.all([r,s]),a=u.AES.decrypt(i.toString(),e);try{this.db=new o.Database(this._cryptJsWordArrayToUint8Array(a)),this.getTags()}catch{return Promise.reject()}return Promise.resolve(!0)}getUsers(){return this._execQueryAndFetchResults("SELECT * FROM users ORDER BY followersCount DESC")}getDataForPeriod(e,t){this._prepareUniqueDataForPeriod(e,t);const n={};return n["overviewStatsForPeriod"]=this._getOverviewStatsForPeriod(e,t),n["engagementDataByTagForPeriod"]=this._getEngagementDataByTagForPeriod(e,t),n["engagementDataByUserAndTagForPeriod"]=this._getEngagementDataByUserAndTagForPeriod(e,t),n["dailyUniqueCommentorsByTag"]=this._getDailyUniqueCommentorsByTagForPeriod(e,t),n["dailyStatsByTag"]=this._getDailyStatsByTag(e,t),n["wordCount"]=this._getWordStatsByTag(e,t),n["topTweets"]=this._getTopTweetsByTag(e,t),n}getUserMetricsForPeriod(e,t,n){const r="\n      SELECT\n        userMetrics.followersCount,\n        userMetrics.listedCount,\n        DATE(userMetrics.recordedAt, 'unixepoch') AS reportingDay\n      FROM\n        users\n      JOIN\n        userMetrics ON users.userId = userMetrics.userId\n      WHERE\n        username = $username AND\n        reportingDay >= DATE($start, 'unixepoch') AND\n        reportingDay <= DATE($end, 'unixepoch')\n      GROUP BY\n        reportingDay\n      ORDER BY\n        reportingDay",s=this._execQueryAndFetchResults(r,{$start:t,$end:n,$username:e}),o={followersCount:[],listedCount:[]};return s.forEach((e=>{o.followersCount.push([e.reportingDay,e.followersCount]),o.listedCount.push([e.reportingDay,e.listedCount])})),o}getUser(e){return this._execQueryAndFetchResults("SELECT * FROM users WHERE username LIKE $username",{$username:e})[0]}getTagsForUser(e){return this._execQueryAndFetchResults("SELECT\n        tag\n      FROM\n        users\n      JOIN\n        userTags ON users.userId = userTags.userId\n      WHERE\n        users.username LIKE $username",{$username:e})}getUserProfileChanges(e){return this._execQueryAndFetchResults("SELECT\n        userProfileChanges.*,\n        ROW_NUMBER() OVER(ORDER BY recordedAt) AS rowNumber\n       FROM\n        userProfileChanges\n       JOIN\n        users ON users.userId = userProfileChanges.userId\n      WHERE\n        username LIKE $username",{$username:e})}getUserDataForPeriod(e,t,n){this._prepareUniqueDataForPeriod(t,n);const r="\n      SELECT * FROM (SELECT\n        users.userId,\n        COUNT(*) AS tweetsSum,\n        SUM(likesCount) AS likesSum,\n        SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n        SUM(quoteCount) AS quoteSum,\n        SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n        SUM(retweetCount) AS retweetSum,\n        SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n        SUM(replyCount) AS replySum,\n        SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n        SUM(tweets.numUniqueCommentors) / CAST(COUNT(*)  AS REAL) AS uniqueCommentorsPerTweet,\n        SUM(hasVideo) AS videoSum,\n        100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n        SUM(hasPhoto) AS photoSum,\n        100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n        MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n        DATE(tweets.createdAt, 'unixepoch') AS reportingDay\n      FROM\n        users\n      LEFT JOIN\n        (SELECT\n          *\n         FROM\n          tweets\n         WHERE\n          tweets.createdAt >= $start AND\n          tweets.createdAt <= $end AND\n          isRetweet = 0) AS tweets ON users.userId = tweets.userId\n      WHERE\n          users.username LIKE $username\n      GROUP BY\n        reportingDay\n      ORDER BY\n        reportingDay) AS data\n      LEFT JOIN\n        dailyUniqueCommentorsForPeriodByUser AS u ON data.userId = u.userId AND\n        data.reportingDay = u.reportingDay",s=this._execQueryAndFetchResults(r,{$start:t,$end:n,$username:e}),o={tweetsSum:[],likesSum:[],likesPerTweet:[],quoteSum:[],quotesPerTweet:[],retweetSum:[],retweetsPerTweet:[],replySum:[],repliesPerTweet:[],uniqueCommentorsPerTweet:[],uniqueCommentors:[],videoSum:[],percentWithVideo:[],photoSum:[],percentWithPhoto:[],minKnownAudience:[],interactionsSum:[],interactionsPerTweet:[]};s.forEach((e=>{null!=e.reportingDay&&(o.quoteSum.push([e.reportingDay,e.quoteSum]),o.quotesPerTweet.push([e.reportingDay,e.quotesPerTweet]),o.repliesPerTweet.push([e.reportingDay,e.repliesPerTweet]),o.replySum.push([e.reportingDay,e.replySum]),o.retweetSum.push([e.reportingDay,e.retweetSum]),o.retweetsPerTweet.push([e.reportingDay,e.retweetsPerTweet]),o.tweetsSum.push([e.reportingDay,e.tweetsSum]),o.likesSum.push([e.reportingDay,e.likesSum]),o.likesPerTweet.push([e.reportingDay,e.likesPerTweet]),o.minKnownAudience.push([e.reportingDay,e.minKnownAudience]),o.uniqueCommentors.push([e.reportingDay,e.numUniqueCommentors]),o.uniqueCommentorsPerTweet.push([e.reportingDay,e.uniqueCommentorsPerTweet]),o.interactionsSum.push([e.reportingDay,e.interactionsSum]),o.interactionsPerTweet.push([e.reportingDay,e.interactionsPerTweet]),o.photoSum.push([e.reportingDay,e.photoSum]),o.percentWithPhoto.push([e.reportingDay,e.percentWithPhoto]),o.videoSum.push([e.reportingDay,e.videoSum]),o.percentWithVideo.push([e.reportingDay,e.percentWithVideo]),o.percentWithVideo.push([e.reportingDay,e.percentWithVideo]))}));const u="\n      SELECT\n        tweets.*\n      FROM\n        users\n      JOIN\n        tweets ON users.userId = tweets.userId\n      WHERE\n        users.username LIKE $username AND\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0\n      ORDER BY\n        likesCount + quoteCount + retweetCount + replyCount DESC\n      LIMIT 10",i=this._execQueryAndFetchResults(u,{$start:t,$end:n,$username:e});return o["topTweets"]=i,o}_prepareUniqueDataForPeriod(e,t){this._fillUniqueCommentorsForPeriodByTag(e,t),this._fillUniqueCommentorsForPeriodByUser(e,t),this._fillDailyUniqueCommentorsForPeriodByTag(e,t),this._fillDailyUniqueCommentorsForPeriodByUser(e,t)}_fillDailyUniqueCommentorsForPeriodByTag(e,t){this.db.exec("DROP TABLE IF EXISTS dailyUniqueCommentorsForPeriodByTag"),this.db.exec('CREATE TABLE "dailyUniqueCommentorsForPeriodByTag" (\n      "tag"\tTEXT NOT NULL,\n      "reportingDay"\tTEXT NOT NULL,\n      "numUniqueCommentors"\tINTEGER NOT NULL\n    );');const n="SELECT\n      uniqueCommentors,\n      tag,\n      DATE(createdAt, 'unixepoch') AS reportingDay\n    FROM\n      tweets\n    JOIN\n      userTags ON tweets.userId = userTags.userId\n    WHERE\n      tweets.createdAt >= $start AND\n      tweets.createdAt <= $end AND\n      isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};r.forEach((e=>{s.hasOwnProperty(e.tag)||(s[e.tag]={}),s[e.tag].hasOwnProperty(e.reportingDay)||(s[e.tag][e.reportingDay]=new Set),e.uniqueCommentors=e.uniqueCommentors+"";const t=e.uniqueCommentors.split(",");t.forEach((t=>{"null"!=t&&s[e.tag][e.reportingDay].add(t)}))}));for(const[o,u]of Object.entries(s))for(const[e,t]of Object.entries(u))this.db.run("INSERT INTO dailyUniqueCommentorsForPeriodByTag\n            (tag,\n             reportingDay,\n             numUniqueCommentors)\n            VALUES (?, ?, ?)",[o,e,t.size])}_fillUniqueCommentorsForPeriodByUser(e,t){this.db.exec("DROP TABLE IF EXISTS uniqueCommentorsForPeriodByUser"),this.db.exec('CREATE TABLE "uniqueCommentorsForPeriodByUser" (\n      "userId"\tSTRING NOT NULL,\n      "numUniqueCommentors"\tINTEGER NOT NULL,\n      PRIMARY KEY("userId")\n    )');const n="SELECT\n        userId,\n        tweetId,\n        createdAt,\n        uniqueCommentors\n      FROM\n        tweets\n      WHERE\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};r.forEach((e=>{s.hasOwnProperty(e.userId)||(s[e.userId]=new Set),e.uniqueCommentors=e.uniqueCommentors+"";const t=e.uniqueCommentors.split(",");t.forEach((t=>{"null"!=t&&s[e.userId].add(t)}))}));for(const[o,u]of Object.entries(s))this.db.run("INSERT INTO uniqueCommentorsForPeriodByUser (userId, numUniqueCommentors) VALUES (?, ?)",[o,u.size])}_fillDailyUniqueCommentorsForPeriodByUser(e,t){this.db.exec("DROP TABLE IF EXISTS dailyUniqueCommentorsForPeriodByUser"),this.db.exec('CREATE TABLE "dailyUniqueCommentorsForPeriodByUser" (\n      "userId"\tSTRING NOT NULL,\n      "reportingDay"\tTEXT NOT NULL,\n      "numUniqueCommentors"\tINTEGER NOT NULL\n    )');const n="SELECT\n        userId,\n        tweetId,\n        DATE(createdAt, 'unixepoch') AS reportingDay,\n        uniqueCommentors\n      FROM\n        tweets\n      WHERE\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};r.forEach((e=>{const t=e.userId+"_"+e.reportingDay;s.hasOwnProperty(t)||(s[t]=new Set),e.uniqueCommentors=e.uniqueCommentors+"";const n=e.uniqueCommentors.split(",");n.forEach((e=>{"null"!=e&&s[t].add(e)}))}));for(const[o,u]of Object.entries(s)){const e=o.split("_"),t=e[0],n=e[1];this.db.run("INSERT INTO dailyUniqueCommentorsForPeriodByUser\n          (userId,\n           reportingDay,\n           numUniqueCommentors)\n         VALUES\n          (?, ?, ?)",[t,n,u.size])}}_fillUniqueCommentorsForPeriodByTag(e,t){this.db.exec("DROP TABLE IF EXISTS uniqueCommentorsForPeriodByTag"),this.db.exec('CREATE TABLE "uniqueCommentorsForPeriodByTag" (\n      "tag"\tSTRING NOT NULL,\n      "numUniqueCommentors"\tINTEGER NOT NULL,\n      PRIMARY KEY("tag")\n    )');const n="\n      SELECT\n        tweetId,\n        uniqueCommentors,\n        tag\n      FROM\n        tweets\n      JOIN\n        userTags ON tweets.userId = userTags.userId\n      WHERE\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};r.forEach((e=>{s.hasOwnProperty(e.tag)||(s[e.tag]=new Set),e.uniqueCommentors=e.uniqueCommentors+"";const t=e.uniqueCommentors.split(",");t.forEach((t=>{"null"!=t&&s[e.tag].add(t)}))}));for(const[o,u]of Object.entries(s))this.db.run("INSERT INTO uniqueCommentorsForPeriodByTag (tag, numUniqueCommentors) VALUES (?, ?)",[o,u.size])}_getWordStatsByTag(e,t){const n="\n      SELECT\n        tag,\n        body\n      FROM\n        users\n      JOIN\n        userTags ON users.userId = userTags.userId\n      JOIN\n        tweets ON users.userId = tweets.userId\n      WHERE\n        tweets.createdAt >= $start AND\n        tweets.createdAt <= $end AND\n        isRetweet = 0",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};r.forEach((e=>{const t=e.tag;s.hasOwnProperty(t)||(s[t]={});const n=(0,o.removeStopwords)(e.body.split(" "),[...o.eng,...o.hye,...i.customStopwords]);n.forEach((e=>{s[t].hasOwnProperty(e)||(s[t][e]=0),s[t][e]+=1}))}));const u={};for(const[o,i]of Object.entries(s)){const e=[];for(const[t,n]of Object.entries(i))e.push([t,n]);e.sort((function(e,t){return t[1]-e[1]})),u[o]=e.slice(0,20)}return u}_getTopTweetsByTag(e,t){const n="\n      SELECT\n        *\n      FROM\n        (SELECT\n          tag,\n          tweetId,\n          row_number() OVER\n            (PARTITION BY\n              tag\n             ORDER BY\n              likesCount + quoteCount + retweetCount + replyCount DESC) AS tagRank\n          FROM\n            users\n          JOIN\n            userTags ON users.userId = userTags.userId\n          JOIN\n            tweets ON users.userId = tweets.userId\n          WHERE\n            tweets.createdAt >= $start AND\n            tweets.createdAt <= $end AND\n            isRetweet = 0\n          ORDER BY\n            tag,\n            tagRank)\n      WHERE\n        tagRank <= 5",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};return r.forEach((e=>{s.hasOwnProperty(e.tag)||(s[e.tag]=[]),s[e.tag].push(e)})),s}_getDailyStatsByTag(e,t){const n="\n      SELECT\n        tag,\n        COUNT(*) AS tweetsSum,\n        SUM(likesCount) AS likesSum,\n        SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n        SUM(quoteCount) AS quoteSum,\n        SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n        SUM(retweetCount) AS retweetSum,\n        SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n        SUM(replyCount) AS replySum,\n        SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n        SUM(tweets.numUniqueCommentors) / CAST(COUNT(*)  AS REAL) AS uniqueCommentorsPerTweet,\n        SUM(hasVideo) AS videoSum,\n        100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n        SUM(hasPhoto) AS photoSum,\n        100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n        MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n        DATE(tweets.createdAt, 'unixepoch') AS reportingDay\n      FROM\n        users\n      JOIN\n        userTags ON users.userId = userTags.userId\n      LEFT JOIN\n        (SELECT\n          *\n         FROM\n          tweets\n         WHERE\n          tweets.createdAt >= $start AND\n          tweets.createdAt <= $end AND\n          isRetweet = 0) AS tweets ON users.userId = tweets.userId\n      GROUP BY\n        tag,\n        reportingDay\n      ORDER BY\n        tag,\n        reportingDay",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={tweetsSum:{},likesSum:{},likesPerTweet:{},quoteSum:{},quotesPerTweet:{},retweetSum:{},retweetsPerTweet:{},replySum:{},repliesPerTweet:{},uniqueCommentorsPerTweet:{},videoSum:{},percentWithVideo:{},photoSum:{},percentWithPhoto:{},minKnownAudience:{},interactionsSum:{},interactionsPerTweet:{}};return r.forEach((e=>{s.likesSum.hasOwnProperty(e.tag)||(s.tweetsSum[e.tag]=[],s.likesSum[e.tag]=[],s.likesPerTweet[e.tag]=[],s.uniqueCommentorsPerTweet[e.tag]=[],s.interactionsSum[e.tag]=[],s.interactionsPerTweet[e.tag]=[],s.videoSum[e.tag]=[],s.percentWithVideo[e.tag]=[],s.photoSum[e.tag]=[],s.percentWithPhoto[e.tag]=[]),null!=e.reportingDay&&(s.tweetsSum[e.tag].push([e.reportingDay,e.tweetsSum]),s.likesSum[e.tag].push([e.reportingDay,e.likesSum]),s.likesPerTweet[e.tag].push([e.reportingDay,e.likesPerTweet]),s.uniqueCommentorsPerTweet[e.tag].push([e.reportingDay,e.uniqueCommentorsPerTweet]),s.interactionsSum[e.tag].push([e.reportingDay,e.interactionsSum]),s.interactionsPerTweet[e.tag].push([e.reportingDay,e.interactionsPerTweet]),s.photoSum[e.tag].push([e.reportingDay,e.photoSum]),s.percentWithPhoto[e.tag].push([e.reportingDay,e.percentWithPhoto]),s.videoSum[e.tag].push([e.reportingDay,e.videoSum]),s.percentWithVideo[e.tag].push([e.reportingDay,e.percentWithVideo]))})),s}_getDailyUniqueCommentorsByTagForPeriod(e,t){const n="\n      SELECT\n        *\n      FROM\n        dailyUniqueCommentorsForPeriodByTag\n      WHERE\n        reportingDay >= DATE($start, 'unixepoch') AND\n        reportingDay <= DATE($end, 'unixepoch')\n      ORDER BY\n        tag,\n        reportingDay",r=this._execQueryAndFetchResults(n,{$start:e,$end:t}),s={};return r.forEach((e=>{s.hasOwnProperty(e.tag)||(s[e.tag]=[]),s[e.tag].push([e.reportingDay,e.numUniqueCommentors])})),s}_getOverviewStatsForPeriod(e,t){const n="SELECT\n        COUNT(*) AS numTweets,\n        SUM(likesCount) AS likesSum,\n        SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n        SUM(quoteCount) AS quoteSum,\n        SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n        SUM(retweetCount) AS retweetSum,\n        SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n        SUM(replyCount) AS replySum,\n        SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n        SUM(tweets.numUniqueCommentors) / CAST(COUNT(*)  AS REAL) AS uniqueCommentorsPerTweet,\n        SUM(hasVideo) AS videoSum,\n        100 * SUM(hasVideo) / CAST(COUNT(*)  AS REAL) AS percentWithVideo,\n        SUM(hasPhoto) AS photoSum,\n        100 * SUM(hasPhoto) / CAST(COUNT(*)  AS REAL) AS percentWithPhoto,\n        MAX(MAX(videoViews), MAX(likesCount), MAX(replyCount), MAX(retweetCount), MAX(quoteCount)) AS minKnownAudience,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n        users.userId,\n        username,\n        profileImage,\n        name,\n        uniqueCommentorsForPeriodByUser.numUniqueCommentors AS uniqueCommentorsSum\n      FROM\n        users\n      LEFT JOIN\n        (SELECT\n          *\n         FROM\n          tweets\n         WHERE\n          tweets.createdAt >= $start AND\n          tweets.createdAt <= $end AND\n          isRetweet = 0) AS tweets ON users.userId = tweets.userId\n      LEFT JOIN\n        uniqueCommentorsForPeriodByUser ON users.userId = uniqueCommentorsForPeriodByUser.userId\n      GROUP BY\n        users.userId";return this._execQueryAndFetchResults(n,{$start:e,$end:t})}_getEngagementDataByUserAndTagForPeriod(e,t){const n="SELECT\n        COUNT(*) AS numTweets,\n        SUM(likesCount) AS likesSum,\n        SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n        SUM(quoteCount) AS quoteSum,\n        SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n        SUM(retweetCount) AS retweetSum,\n        SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n        SUM(replyCount) AS replySum,\n        SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n        users.userId,\n        profileImage,\n        username,\n        tag\n      FROM\n        users\n      LEFT JOIN\n        (SELECT\n          *\n         FROM\n          tweets\n         WHERE\n          tweets.createdAt >= $start AND\n          tweets.createdAt <= $end AND\n          isRetweet = 0) AS tweets ON users.userId = tweets.userId\n      LEFT JOIN\n        userTags ON users.userId = userTags.userId\n      GROUP BY\n        users.userId,\n        userTags.tag";return this._execQueryAndFetchResults(n,{$start:e,$end:t})}_getEngagementDataByTagForPeriod(e,t){const n="SELECT\n        COUNT(*) AS numTweets,\n        SUM(likesCount) AS likesSum,\n        SUM(likesCount) / CAST(COUNT(*)  AS REAL) AS likesPerTweet,\n        SUM(quoteCount) AS quoteSum,\n        SUM(quoteCount) / CAST(COUNT(*)  AS REAL) AS quotesPerTweet,\n        SUM(retweetCount) AS retweetSum,\n        SUM(retweetCount) / CAST(COUNT(*)  AS REAL) AS retweetsPerTweet,\n        SUM(replyCount) AS replySum,\n        SUM(replyCount) / CAST(COUNT(*)  AS REAL) AS repliesPerTweet,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) AS interactionsSum,\n        (SUM(likesCount) + SUM(quoteCount) +  SUM(retweetCount)  + SUM(replyCount)) / CAST(COUNT(*)  AS REAL) AS interactionsPerTweet,\n        users.userId,\n        uniqueCommentorsForPeriodByTag.tag,\n        uniqueCommentorsForPeriodByTag.numUniqueCommentors AS uniqueCommentorsSum\n      FROM\n        users\n      LEFT JOIN\n        (SELECT\n          *\n         FROM\n          tweets\n         WHERE\n          tweets.createdAt >= $start AND\n          tweets.createdAt <= $end AND\n          isRetweet = 0) AS tweets ON users.userId = tweets.userId\n      LEFT JOIN\n        userTags ON users.userId = userTags.userId,\n        uniqueCommentorsForPeriodByTag ON uniqueCommentorsForPeriodByTag.tag = userTags.tag\n      GROUP BY\n        userTags.tag";return this._execQueryAndFetchResults(n,{$start:e,$end:t})}getTags(){const e="SELECT DISTINCT(tag) FROM userTags";return this._execQueryAndFetchResults(e,{})}_execQueryAndFetchResults(e,t){var n=this.db.prepare(e);n.bind(t);const r=[];while(n.step())r.push(n.getAsObject(null,{useBigInt:!0}));return r}_resultsToDictionaries(e,t){const n=[];return t.forEach((t=>{const r={};e.forEach(((e,n)=>r[e]=t[n])),n.push(r)})),n}_cryptJsWordArrayToUint8Array(e){const t=e.sigBytes,n=e.words,r=new Uint8Array(t);var s=0,o=0;while(1){if(s==t)break;var u=n[o++];if(r[s++]=(4278190080&u)>>>24,s==t)break;if(r[s++]=(16711680&u)>>>16,s==t)break;if(r[s++]=(65280&u)>>>8,s==t)break;r[s++]=255&u}return r}}s()(i,"customStopwords",["&amp;","❗️","↵","","🔴"])},1168:(e,t,n)=>{"use strict";n.d(t,{Z:()=>T});var r=n(9835);function s(e,t,n,s,o,u){const i=(0,r.up)("q-date"),a=(0,r.up)("q-popup-proxy"),S=(0,r.up)("q-btn");return(0,r.wg)(),(0,r.j4)(S,{icon:"event",color:"primary",label:"Select Report Period",push:""},{default:(0,r.w5)((()=>[(0,r.Wm)(a,{"transition-show":"scale","transition-hide":"scale"},{default:(0,r.w5)((()=>[(0,r.Wm)(i,{modelValue:s.dateRange,"onUpdate:modelValue":t[0]||(t[0]=e=>s.dateRange=e),minimal:"",range:"",square:"",onRangeEnd:s.reportRequested},null,8,["modelValue","onRangeEnd"])])),_:1})])),_:1})}var o=n(499);const u={props:{from:{required:!0,type:String},to:{required:!0,type:String}},emits:["reportRequested"],setup(e,{emit:t}){const n=(0,o.iH)({from:e.from,to:e.to}),r=e=>{t("reportRequested",n.value)};return{reportRequested:r,dateRange:n}}};var i=n(1639),a=n(4455),S=n(2765),A=n(7088),m=n(9984),d=n.n(m);const C=(0,i.Z)(u,[["render",s]]),T=C;d()(u,"components",{QBtn:a.Z,QPopupProxy:S.Z,QDate:A.Z})},2480:()=>{},7607:()=>{},803:()=>{},9547:()=>{}}]);